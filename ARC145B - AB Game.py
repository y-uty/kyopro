n, a, b = map(int, input().split())

# a <= bのとき、Aliceが初手で取れるだけとると
# n%a < a <= b しか残らず、Bobは1枚も取れずに負ける
# ただし、n < aのときは、Aliceが初手1枚も取れずに負ける
if a <= b:
    print(max([n-a+1, 0]))
    exit()

# 以下, a > b の場合のみを考える
# Aliceが初手でBobを負け確にできなかったとき、
# 先手後手が入れ替わって、a < bのときと同じ状況、
# すなわちBobが勝ち確の状態になってしまう
# よって、AliceがBobに手番を譲ってなお勝てるのは、
# Aliceが初手で取った後の石の数をb未満にできるときだけである

# たとえば、a=5, b=3, ゲーム18までを考えると、
# ゲーム1~4: Aliceが何もできず負け
# ゲーム5~7: Aliceが5個取ってBobの負け
# ゲーム8~9: Aliceは最低5個取らねばならず、残りBobが3個取るとAliceが取れず負け
# ゲーム10~12: Aliceが5*2=10個取ってBobの負け
# ゲーム13~14: Aliceは最低5個取らねばならず、残りBobが取れるだけ取ると3未満になりAlice負け
# ゲーム15~17: Aliceが5*3=15個取ってBobの負け
# ゲーム18: ゲーム13~14と同様にAlice負け

if n < a:
    print(0)
    exit()

k = n-(a-1)
x, y = k//a, k%a
ans = x*b + min([y, b])
print(ans)
