n = int(input())

# 「辞書順」と言われたら、文字列を先頭から決めていくのがセオリー
# ...だが、今回は構成した文字列(カッコ列)が「正しいかどうか？」を考えなければならない

# 長さの制約N<=20、使える文字列が2種類ということを考えると、
# bit全探索ができそうである
# 0を「(」、1を「)」とみなした文字列が「正しいカッコ列か？」がO(N)で判定できれば、
# 全体の計算量はO(N * 2^N)で、最大20*(2^20)=20971520、間に合いそうである

# 正しいカッコ列の判定方法は、正直知っていればそれまでで、考え方としては
#  1. 最小単位の正しいカッコ列は、()である
#  2. その外側から0回以上()で囲ってよい、その結果((()))のようになる
#  3. それを1個以上順番につなげてよい、その結果()((()))(())のようになる
#  4. 2, 3を好きな順番で好きなだけ行ってよい
# ということから、最小単位()を1つずつ取り除いていくことで、空文字にできる
# なぜなら、()がつながっているだけなら端から消えていくだけだし、
# ((()))の構造は、内側から順番に消えていくため
# 従って、空文字にできなければ、それは正しいカッコ列を作成する操作以外の操作が行われており、不適


# 「(」と「)」の数が合わないと正しいカッコ列にならないので、奇数文字数の正しいカッコ列は存在しない
if n%2:
    exit()

# bit全探索: 2^N通りの文字列
x = 2**n
# 0を「(」、1を「)」とみなしたから、辞書順はそのまま数字の小さい順である
for i in range(x):
    # 0埋めN文字の2進数に変換
    b = format(i, '0'+str(n)+'b')
    b_judge = b
    for _ in range(n//2):
        # N/2回、()を除去 判定だけならビット列のまま01を除去すればよい
        b_judge = b_judge.replace('01', '')

    if b_judge=='':
        # 出力時にカッコ列に変換
        print(b.replace('0', '(').replace('1', ')'))
