n = int(input())
s = ['_'] + list(str(input()))
MOD = 10**9+7

# DPで解く
# 元の文字列をS、作りたい文字列(今回は'atcoder')をTとするとき、
# dp[i][j]:= Tのi文字目までの文字列を、Sのj文字目までで作る選び方の数 とする

# Sのj文字目でTのi文字目が初めて現れるとき、
# Sのj-1文字目まででTのi-1文字目までが作れる選び方だけ、Tのi文字目までが作れるようになる
# たとえばSの5文字目まででatが5通り作れるとき、かつS[6]=cのとき、
# 5通りのatの選び方の末尾にそのままcをつなげられるから、atcの選び方も5通りである
# よって、Sのj文字目でTのi文字目が初めて現れるときの遷移は
# dp[i][j] = dp[i-1][j-1]

# Sのj文字目でTのi文字目が現れるのが2回目以降であるとき、
# at->atcの例で考えると、
# cが2回目に登場したとき、末尾にcをつけてatcを作れるような選び方は、
# Sのj-1文字目まででTのi-1文字目までが作れる選び方
# 　+ Sのj-1文字目まででTのi文字目までが作れる選び方 である
# つまり、前述の例で言えば、atを作る選び方+atcを作る選び方、となる
# どちらを選んでも(余計なcは無視して)atcを作ることができる
# よって、その遷移は
# dp[i][j] = dp[i-1][j-1] + dp[i][j-1]

# 3回目以降についても、dp[i][j-1]には2回目までの選び方が記録されているから同様である
# また、dp配列を0で初期化すれば、初めて現れる場合のdp[i][j-1]=0であるため、
# 遷移を dp[i][j] = dp[i-1][j-1] + dp[i][j-1] で統一できる

x = '_atcoder'
dp = [[0]*(n+1) for _ in range(len('atcoder')+1)]
dp[0] = [1]*(n+1)

for i in range(1, 8):
    for j in range(1, n+1):

        if s[j]==x[i]:
            dp[i][j] = dp[i-1][j-1] + dp[i][j-1]
        else:
            dp[i][j] = dp[i][j-1]
        
        dp[i][j] %= MOD

print(dp[-1][-1])