import collections
n, m = map(int, input().split())
a = list(map(int, input().split()))

# 区間和なので、累積和の要領で解く

# 左端を固定したときに、(区間和)%M=0となるような右端を高速に求めたい
# まず、左端がA1のとき、予め求めた累積和%M=0となる位置が条件を満たす
# これは、累積和の配列に対して連想配列で個数をカウントしておけばO(1)でわかる
# 次に、左端がA2となったとき、元の累積和全体からA1が引かれる
# 差分(増分?)を考えると、元の累積和がA1だったものが次に%M=0になる
# よって、左端がA2のときは、元の累積和がA1となる位置の個数を数えればよい
# 以降も同様で、左端がA3のときは、元の累積和がA1+A2(元の累積和の2項目)となる位置の個数
# とすることで、各左端において、条件を満たす右端の位置をO(1)で求められそうとわかる

# ただし、単に和だけを考えると、Mの倍数は無数に存在するため、
# 連想配列から個数を取得するのが難しいので、累積和をとる段階で%Mしておく
# 左端をずらしながら、1つ前の累積和の剰余となる右端を探していくことで答えが求まる
# 通り過ぎた剰余は今後使えないので、連想配列に対して-1するのを忘れずに

cumrem = []
cum = 0
for i in range(n):
    cum += a[i]
    cum %= m
    cumrem.append(cum)

cumremcnt = collections.Counter(cumrem)

ans = 0
diff = 0
for i in range(n):
    ans += cumremcnt[diff]
    diff = cumrem[i]
    cumremcnt[cumrem[i]] -= 1

print(ans)