n = int(input())
a = [-1] + list(map(int, input().split()))

# 条件がループする問題 => どこか1つを固定して、そこから順番に決めていく
# 始点に戻ってきたとき、条件に矛盾しなければ、選べる答えの候補とする

# この問題では、各条件に対する選択肢が「餌をあげる/あげない」の2種類なので、
# 1つめの条件について「あげる」場合、「あげない」場合とした2パターンを考える
# このうち、条件に矛盾しない かつ より最適なもの(本問では最小値)が答え

# 状態を「i個目までの条件で」「何を選択したか」としたときの最小値を求めるdp[i][j]を考える
# 今回は、餌をあげたか？に対して、'No': 0, 'Yes': 1 とする
# 遷移は、配るdpで
#   条件iで'No'を選択  -> 条件i+1では'Yes'しか選択できないから、
#     dp[i+1][1] = min(dp[i][0] + Ai+1, dp[i+1][1])
#   条件i-1で'Yes'を選択 -> 条件iではどちらも選択できるから、
#     dp[i+1][1] = min(dp[i][1] + Ai+1, dp[i+1][1])
#     dp[i+1][0] = min(dp[i][1], dp[i+1][0])

INF = 10**18

##### Sub.2 貰うdpでもよい(むしろこっちの方がシンプル) #####
# 条件iでYesを選ぶ -> 条件i-1でYes/Noどちらを選んでもよい
#   dp[i][1] = min(dp[i-1][0] + Ai, dp[i-1][1] + Ai)
# 条件iでNoを選ぶ -> 条件i-1でYesを選んだ場合のみ可能
#   dp[i][1] = dp[i-1][0]

# 条件1でNoとした場合のdp
dp_1n = [[INF]*2 for _ in range(n+1)]
dp_1n[1][0] = 0
for i in range(2, n+1):
    
    # 今回はYesを選択する
    dp_1n[i][1] = min(dp_1n[i-1][0], dp_1n[i-1][1]) + a[i]

    # 今回はNoを選択する
    dp_1n[i][0] = dp_1n[i-1][1]

# 条件1でNoなので、条件NはYesでなければならない
ans_1n = dp_1n[n][1]


# 条件1でYesとした場合のdp
dp_1y = [[INF]*2 for _ in range(n+1)]
dp_1y[1][1] = a[1]
for i in range(2, n+1):
    
    # 今回はYesを選択する
    dp_1y[i][1] = min(dp_1y[i-1][0], dp_1y[i-1][1]) + a[i]

    # 今回はNoを選択する
    dp_1y[i][0] = dp_1y[i-1][1]

# 条件1でYesなので、条件NはYesでもNoでもよい
ans_1y = min(dp_1y[n][0], dp_1y[n][1])

# より小さい方が答え
print(min(ans_1n, ans_1y))