n, k = map(int, input().split())
a = list(map(int, input().split()))

# dp[i]:= 石の残りがi個のときからゲームを始めて、先手が取れる石の最大個数
# とすると、明らかにdp[0]=0, dp[1]=1, となることから
# dp[0]から逆順にdp[N]まで決めていく

# dp[x]について考えるとき、dp[0]~dp[x-1]までが確定している
# 残りx個から、K通り(A1, A2, ... , AK)の石のとり方があるが、
# その後、手番が変わり後手番になったとき、後手が取れる石の最大個数は
# 後手を先手としてdpテーブルを見ればわかり、具体的にはdp[x-A]である
# また、A1=1より、石は必ず全て取りきれる、すなわち高橋の数+青木の数=Nでゲームが終わるから、
# xから高橋がA取った残りを高橋がdp[x-A]取った場合、さらにNに満たない分は高橋が取ることになる

# 以上より、dp[x] = Max( Ai + {(N - Ai) - dp[x-Ai]} ) | i = 1~K となる

dp = [0]*(n+1)
for i in range(1, n+1):
    for j in range(k):

        # a[j]は、それが残りの石の数i以下であるときのみ選択可能
        if a[j] <= i:
            dp[i] = max(dp[i], a[j]+ i-a[j]-dp[i-a[j]])


print(dp[n])